# 4.1 NL조인

> 참고
<BR>1. https://velog.io/@wooncloud/NL%EC%A1%B0%EC%9D%B8<br>

## 4.1.1 NL조인 기본 매커니즘

<img src='../img/4.1_1.JPG' width='300' height='150'>

위 그림의 사원과 고객 테이블이 있다.
<BR>

이 두 테이블에서 1996년 1월 1일 이후 입사한 사원이 관리하는 고객 테이터를 추출하는 프로그램을 작성해 보자.

```
select e.사원, c.고객명, c.전화번호
  from 사원 e, 고객 c
 where e.입사일자 >= '19960101'
   and c.관리사원번호 = e.사원번호
```
지금은 위의 SQL문을 사용하면 원하는 결과집합을 추출할 수 있지만,
SQL이 탄생하기 전에는 두 테이블을 조인하는 프로그램을 개발자가 직접 작성해야만 했다.
<BR>

가장 쉽게 생각할 수 있는 방식은 사원 테이블로 부터 1996년 1월 1일 이후 입사한 사원을 찾아 '건건이' 고객 테이블에서 사원번호가 일치하는 레코드를 찾는 것이다. **이것이 바로 <u>Nested Loop조인</u>이 사용하는 알고리즘이다.**
<br>

<img src='../img/4.1_2.JPG' width='300' height='150'>

NL조인은 위 중첩 루프문과 같은 수행 구조를 사용한다.

```
BEGIN
    FOR OUTER IN (SEELCT 사원번호, 사원명 
                    FROM 사원
                   WHERE 입사일자 >= '19960101')
    LOOP --OUTER 루프
        FOR INNER IN (SELECT 고객명, 전화번호
                        FROM 고객
                       WHERE 관리사원번호 = OUTER.사원번호)
        LOOP --INNER 루프
            DBMS_OUTPUT.OUT_LINE( 
                OUTER.사원명 || ' : ' || INNER.고객명 || ' : ' || INNER.전화번호
            );
    END LOOP;
        END LOOP;
END;
```

중첩 루프문을 사용하는 위 PL코드는 NL조인이 어떤 순서로 데이터를 액세스하는 지 확인 할수 있다.
<BR>

일반적으로 NL조인은 Outer와 Inner 양쪽 테이블 모두 인덱스를 이용한다.
Outer쪽 테이블(사원)은 사이즈가 크지 않으면 인덱스를 이용하지 않을 수 있다.
Table Full Scan 하더라도 그것은 한 번에 그치기 때문이다.
<BR>

반면 Inner쪽 테이블(고객)은 인덱스를 사용해야 한다. 위 PL을 예로 들어, Inner루프에서 관리사원번호로 고객데이터를 검색할 때 인덱스를 이용하지 않으면, 아래 그림과 같이 Outer 루프에서 읽은 건수만큼 Table Full Scan을 반복하기 떄문이다.

<img src='../img/4.1_3.jpg' width='300' height='150'>

> NL조인은 '인덱스를 이용한 조인 방식'이라고 할 수 있다.

<BR>

<img src='../img/4.1_4.jpg' width='400' height='200'>

<BR>

1. 사원_X1 인덱스에서 입사일자 >= '19960101'인 첫 번째 레코드를 찾는다.
1. 인덱스에서 읽은 ROWID로 사원 테이블 레코드를 찾아간다.
1. 사원 테이블에서 읽은 사원번호 '0006'으로 고객_X1 인덱스를 탐색한다.
1. 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블 레코드를 찾아간다.

<BR>

<img src='../img/4.1_5.jpg' width='400' height='200'>

<BR>

5. 고객_X1 인덱스에서 한 건 더 스캔하고 관리사원번호가 '0006'임을 확인한다.
6. 고객_X1 인덱스에서읽은 ROWID로 고객 테이블 레코드를 찾아간다. (고객_X1 인덱스에서 한 건 더 스캔하고는 관리 사원번호가 '0006'보다 크므로 거기서 인덱스 스캔을 멈춘다.)

<BR>

<img src='../img/4.1_6.jpg' width='400' height='200'>

<BR>

7. 사원_X1 인덱스에서 한 건 더 스캔해서 입사일자가 '19960712'인 레코드를 읽는다.
8. 인덱스에서 읽은 ROWID로 사원 테이블 레코드를 찾아간다.
9. 사원 테이블에서 읽은 사원번호 '0003'으로 고객_X1 인덱스를 탐색한다.
10. 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블 레코드를 찾아간다.

<BR>

<img src='../img/4.1_7.jpg' width='400' height='200'>

<BR>

11. 고객_X1 인덱스에서 한 건 더 스캔하고 관리사원번호가 '0003'임을 확인한다.
12. 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블 레코드를 찾아간다.(고객_X1 인덱스에서 한 건 더 스캔하고는 관리사원번호가 '0003'보다 크므로 인덱스 스캔을 멈춘다.)

<BR>

사원_X1 인덱스에서 입사일자 >= '19960101'인 모든 레코드에 대해 같은 과정을 반복한다.

> 소트 머지 조인과 해시 조인도 각각 Sort Area와 Hash Area에 가공해 둔 데이터를 이용한다는 점만 다를 뿐, 기본적인 조인 프로세싱은 다르지 않다.


## 4.1.2 NL조인 실행계획 제어